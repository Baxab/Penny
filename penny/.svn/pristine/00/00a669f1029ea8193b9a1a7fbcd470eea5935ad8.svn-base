#!/usr/bin/env python

import rospy
import actionlib
from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal
from math import radians, degrees
from actionlib_msgs.msg import *
from geometry_msgs.msg import Point
from std_msgs.msg import String, Bool
from controller.msg import ControllerTransition
    
def definition():
    global STATE_NAME
    global CANCEL_GOAL
    global TIME_TO_SOUND_ALARM
    global checkpoints	
    global current_point
    global goalReached
    STATE_NAME = 'state_navigation'
    CANCEL_GOAL = 'cancel_goal'
    TIME_TO_SOUND_ALARM = 180
    checkpoints = [[8.0631,0.9918,0.9772,0.2121], [-5.1741,6.3072,-0.2029,0.9791]]
    doors = [0, 2]
    current_point = 0


def callback(change_state_data):
    global STATE_NAME
    
    if(STATE_NAME in change_state_data.state):
        if(CANCEL_GOAL in change_state_data.data):
            cancel_navigation()
            pub.publish("canceled_goal")
        else:
            goalReached = moveToGoal(checkpoints[current_point][0], checkpoints[current_point][1], checkpoints[current_point][2], checkpoints[current_point][3])
            if(current_points in doors):
                isDoor = "_door"
            else:
                isDoor = ""
            update_checkpoint(goalReached)
            pub.publish(str(goalReached)+isDoor)

def moveToGoal(xGoal, yGoal, zOrientGoal, wOrientGoal):
    global TIME_TO_SOUND_ALARM
    #define a client for to send goal requests to the move_base server through a SimpleActionClient
    ac = actionlib.SimpleActionClient('move_base', MoveBaseAction)
     #wait for the action server to come up
    while(not ac.wait_for_server(rospy.Duration.from_sec(5.0))):
        rospy.loginfo("Waiting for the move_base action server to come up")

    goal = MoveBaseGoal()

    #set up the frame parameters
    goal.target_pose.header.frame_id = "map"
    goal.target_pose.header.stamp = rospy.Time.now()

    # moving towards the goal*/
    goal.target_pose.pose.position =  Point(xGoal,yGoal,0)
    goal.target_pose.pose.orientation.x = 0.0
    goal.target_pose.pose.orientation.y = 0.0
    goal.target_pose.pose.orientation.z = zOrientGoal
    goal.target_pose.pose.orientation.w = wOrientGoal

    rospy.loginfo("Sending goal location ...")
    ac.send_goal(goal)

    ac.wait_for_result(rospy.Duration.from_sec(TIME_TO_SOUND_ALARM))

    if(ac.get_state() ==  GoalStatus.SUCCEEDED):
        rospy.loginfo("You have reached the destination")
        return True
    else:
        rospy.loginfo("The robot failed to reach the destination")
        return False
            
def cancel_navigation():
    ac.cancelAllGoals()
    update_checkpoint(False)
        
def update_checkpoint(goalReached):
    global current_point
    global checkpoints
    if goalReached:
        if current_point < (len(checkpoints)-1):
            current_point += 1
        else:
            current_point = 0
        return True
    else:
        return False

   

               
if __name__ == '__main__':
    rospy.init_node('map_navigation')

    definition()

    rospy.Subscriber('state_machine/control', ControllerTransition, callback)

    pub = rospy.Publisher('state_navigation', String, queue_size=10)
    
    rospy.spin()
    
    
    
