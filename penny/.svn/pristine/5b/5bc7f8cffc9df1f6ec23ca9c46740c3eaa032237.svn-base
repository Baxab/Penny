from geometry_msgs.msg import Pose, PoseArray, Quaternion
from pf_base import PFLocaliserBase
import math
import rospy
import numpy as np
import scipy as sp
from util import rotateQuaternion, getHeading
import random
from numpy import hstack, array
from scipy.cluster.vq import kmeans, kmeans2, vq

from time import time

class PFLocaliser(PFLocaliserBase):
       
    def __init__(self):
        # Call the superclass constructor
        super(PFLocaliser, self).__init__()
        
        # Set motion model parameters
        self.ODOM_ROTATION_NOISE = 1#???? # Odometry model rotation noise
        self.ODOM_TRANSLATION_NOISE = 1#???? # Odometry model x axis (forward) noise
        self.ODOM_DRIFT_NOISE = 1#???? # Odometry model y axis (side-to-side) noise

        # Sensor model parameters
        self.NUMBER_PREDICTED_READINGS = 10 	# Number of readings to predict
        
       
    def initialise_particle_cloud(self, initialpose):
        # Set particle cloud to initialpose plus noise
        poseArray = PoseArray()
        for i in range(self.NUMBER_PREDICTED_READINGS):
            thisPose = Pose()
            thisPose.position.x = initialpose.pose.pose.position.x + (random.gauss(0, 0.1) * self.ODOM_TRANSLATION_NOISE)
            thisPose.position.y = initialpose.pose.pose.position.y + (random.gauss(0, 0.1) * self.ODOM_DRIFT_NOISE)

            rotationAngle = (random.vonmisesvariate(0, 1) * self.ODOM_ROTATION_NOISE)
            thisPose.orientation = rotateQuaternion(initialpose.pose.pose.orientation, rotationAngle)

            poseArray.poses.append(thisPose);
        return poseArray
 
    
    def update_particle_cloud(self, scan):
        # Update particlecloud, given map and laser scan
        poseArray = PoseArray()       
        
        for num, i in enumerate(range(self.NUMBER_PREDICTED_READINGS)):
            totalWeight = 0
            for pose in self.particlecloud.poses:
                totalWeight += self.sensor_model.get_weight(scan, pose)
                
            value = random.random() * totalWeight
            
            for pose in self.particlecloud.poses:
                value -= self.sensor_model.get_weight(scan, pose)
                if value <= 0:
                    break
            #print str(num) + " weight: " + str(self.sensor_model.get_weight(scan, pose))
            poseArray.poses.append(pose)

        # Add some noise to all the particles
        for thisPose in poseArray.poses:
            thisPose.position.x += (random.gauss(0, 0.1) * self.ODOM_TRANSLATION_NOISE)
            thisPose.position.y += (random.gauss(0, 0.1) * self.ODOM_DRIFT_NOISE)

            rotationAngle = (random.vonmisesvariate(0, 1) * self.ODOM_ROTATION_NOISE)
            rotationAngle = rotationAngle % (2 * math.pi)
            thisPose.orientation = rotateQuaternion(thisPose.orientation, rotationAngle)

        self.particle_cloud = poseArray 
        

    def estimate_pose(self):
        # Create new estimated pose, given particle cloud
        # E.g. just average the location and orientation values of each of
        # the particles and return this.
#        estpose = Pose()
#        x_sum = 0
#        y_sum = 0
#        qx_sum = 0
#        qy_sum = 0
#        qz_sum = 0
#        qw_sum = 0
#        for num, i in enumerate(self.particle_cloud.poses):
#    	    x_sum += i.position.x
#    	    y_sum += i.position.y
#    	    qz_sum += i.orientation.z
#    	    qw_sum += i.orientation.w
#
#        estpose.position.x = x_sum / self.NUMBER_PREDICTED_READINGS
#        estpose.position.y = y_sum / self.NUMBER_PREDICTED_READINGS
#        estpose.orientation.z = qz_sum / self.NUMBER_PREDICTED_READINGS
#        estpose.orientation.w = qw_sum / self.NUMBER_PREDICTED_READINGS
#        
#        return estpose
        # Better approximations could be made by doing some simple clustering,
        # e.g. taking the average location of half the particles after 
        
        # throwing away any which are outliers

        k = int(math.sqrt(self.NUMBER_PREDICTED_READINGS/2))

        pos_x = [[] for _ in range(len(self.particle_cloud.poses))]
        pos_y = [[] for _ in range(len(self.particle_cloud.poses))]

        for i in range(len(self.particle_cloud.poses)):
            pos_x[i].append(self.particle_cloud.poses[i].position.x)
            pos_y[i].append(self.particle_cloud.poses[i].position.y)

        f_x = np.array(pos_x)
        f_y = np.array(pos_y)	
        print(f_x)
        print(f_y)
        data = hstack((f_x, f_y))
        print(data)
        
        # computing K-mean, returning an array of centroids and the labels
        centroids, labels = kmeans2(data, k, minit='points')

        count = []
        for i in range(k):
            count.append(0)
        for i,_ in enumerate(self.particle_cloud.poses):
            index = labels[i]
            count[index] += 1

        centroidWithMaxPoses = count.index(max(count))

        estimatedPose = Pose()
        estimatedPose.position.x = centroids[centroidWithMaxPoses][0]
        estimatedPose.position.y = centroids[centroidWithMaxPoses][1]

        return estimatedPose

